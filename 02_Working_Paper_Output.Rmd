---
title: "02 Working Paper"
author: "Nate Breznau & Hung H.V. Nguyen"
date: "`r Sys.Date()`"
output: html_document
---

## R Markdown

```{r setup}

source("R/theoRy.R")
library('tictoc')
library('QCA')

```

## Generate Model Multiverse

### Generate causal and formula matrix

```{r models}
nodes <- c("a","b","c","d","e")
timing <- c(0,-1,-3,-3,-2)
types <- c("otc","test","ctr","ctr", "ctr")
user_mods <- c("a ~ b + d; b ~ c + d", # Model 1
               "a ~ b + c; b ~ c + d", # Model 2
               "a ~ b + c + d; b ~ c + d", # Model 3
               #"a ~ b + d; b ~ c + d; f ~ a + b", # Model 4, add later
               "a ~ b + d; b ~ d; c ~ c", # Model 5
               "a ~ b + d; b ~ c + d + e; e ~ d" # Model 6
               )

tic()
ls_theory <- theoRy(nodes = nodes, timing = timing, types=types, include_subsets = TRUE, user_mods=user_mods)
toc()
```

### Add Model 4

With X4 in the model, the multiverse is huge. for now we simply add the confounding Model 4 as a single model that might threaten this multiverse for illustrative purposes.

Adding a single model with a new variable requires adjusting the node_timing matrix too (we will update this later)

when theoRy is run the model numbers change
1 = 3
2 = 5
3 = 2
4 = 6 (after addition)
5 = 4
6 = 1

```{r m4}
# add X4 to node_timing
ls_theory$node_timing <- ls_theory$node_timing %>% add_row(var_name = "f", timing = 1, type = "ctr", node_name = "X4")

ls_theory$causal_matrix <- find_add_models(causal_matrix = ls_theory$causal_matrix, node_timing = ls_theory$node_timing, user_mods = c("a ~ b + d; b ~ c + d; f ~ a + b"))

# rearrange so that models 1 thru 6 match Table 1 numbering
ls_theory$causal_matrix <- ls_theory$causal_matrix %>%
    mutate(model = dplyr::recode(model,
                  `3` = 1,
                  `5` = 2,
                  `2` = 3,
                  `1166` = 4,
                  `4` = 5,
                  `1` = 6,
                  .default = model
                  )) %>%
    arrange(model)

ls_theory$formula_matrix <- build_formula_matrix(ls_theory$causal_matrix)

```
### Compare Models

```{r models}
cmp_matrix <- add_compatible(ls_theory$formula_matrix, ref_mod = 1) 

## Change ref_mod to whichever is your reference model (using base_mod and model variable in the formula matrix)
```



### Generate DAG formulas

```{r gen_dags}

dag_matrix <- build_dag_matrix(ls_theory$formula_matrix, add_nodes = 2)

```

### Generate Plots

Only need to save models 1-6 for the paper

```{r gen_plots, warning = F}
dag_plots <- plot_dag_matrix(dag_matrix, save_plots = TRUE, choose_plots = c(2,6,8,18,33,34), title_labels = c(3,1,5,2,4,6))


```




##### Playing around with plotting as ggdag

```{r ggdag}

fvector <- strsplit(as.character(formula_matrix[1]), ",")[[1]]
dag_args <- lapply(fvector, as.formula)
additional_args <- list(
     exposure="Xtest",
     outcome="Y"
     )

d1 <- do.call(dagify, c(dag_args, additional_args))


ggdag(d1)

d1plot <- ggdag(d1) +
    geom_dag_edges(edge_color = "green")

```


## QCA

### Build Set Matrix

Here we focus on test_compatible as the outcome (= 1)

We use cmp_matrix to get this information

```{r build_set_matrix}
set_matrix <- build_set_matrix(ls_theory$causal_matrix)

# think about whether we want model numbers in or not, just remove by hand here

set_matrix_nomod <- dplyr::select(set_matrix, -model)
```




### Single Components

This can help us understand the role of single components. However, for most causal models a single component is rarely alone so important. For example a node often requires specific edges before it becomes important (e.g., becomes a confounder or collider)

```{r qca}
#test <- truthTable(set_matrix, "outcome")

pof(setms = select(set_matrix, -c(model,outcome)), outcome = "outcome", data = set_matrix)

# try option relation = "sufficiency"

#inclN = inclusion = what percent of all models have outcome (Y = 1) and this component (X = 1)
#covN = necessity coverage = what percent of all models with this component (X = 1) have the outcome (Y = 1)
#RoN = relevence of necessity = is a necessary condition trivial
```


### Multiple Component Analyses

#### Minimize

Looking only positive outcomes (outcome = 1/MAS = {X1}), this procedure tries to find minimal sets of variables that are present in all positive cases, regardless of if these sets are present in outcome = 0 cases.

```{r minimize}

min_results <- minimize(set_matrix_nomod, details = TRUE, outcome = "outcome")

```


#### Subsets

```{r qca}
superSubset(as.data.frame(causal_matrix_transf_X1), outcome = "outcome")
```

                                      inclN   RoN   covN  
--------------------------------------------------------- 
 1  X1_Xtest                          1.000  0.588  0.257 
 2  X1_Y                              1.000  0.588  0.257 
 3  X1                                1.000  0.034  0.129 
 4  Xtest                             1.000  0.000  0.125 
 5  Xtest_Y                           1.000  0.000  0.125 
 6  Y                                 1.000  0.000  0.125 
 7  X1_Xtest*X1_Y                     1.000  0.865  0.514 
 8  X1_Xtest*X1                       1.000  0.588  0.257 
 9  X1_Xtest*Xtest                    1.000  0.588  0.257 
10  X1_Xtest*Xtest_Y                  1.000  0.588  0.257 
11  X1_Xtest*Y                        1.000  0.588  0.257 
12  X1_Y*X1                           1.000  0.588  0.257 
13  X1_Y*Xtest                        1.000  0.588  0.257 
14  X1_Y*Xtest_Y                      1.000  0.588  0.257 
15  X1_Y*Y                            1.000  0.588  0.257 
16  X1*Xtest                          1.000  0.034  0.129 
17  X1*Xtest_Y                        1.000  0.034  0.129 
18  X1*Y                              1.000  0.034  0.129 
19  Xtest*Xtest_Y                     1.000  0.000  0.125 
20  Xtest*Y                           1.000  0.000  0.125 
21  Xtest_Y*Y                         1.000  0.000  0.125 
22  X1_Xtest*X1_Y*X1                  1.000  0.865  0.514 
23  X1_Xtest*X1_Y*Xtest               1.000  0.865  0.514 
24  X1_Xtest*X1_Y*Xtest_Y             1.000  0.865  0.514 
25  X1_Xtest*X1_Y*Y                   1.000  0.865  0.514 
26  X1_Xtest*X1*Xtest                 1.000  0.588  0.257 
27  X1_Xtest*X1*Xtest_Y               1.000  0.588  0.257 
28  X1_Xtest*X1*Y                     1.000  0.588  0.257 
29  X1_Xtest*Xtest*Xtest_Y            1.000  0.588  0.257 
30  X1_Xtest*Xtest*Y                  1.000  0.588  0.257 
31  X1_Xtest*Xtest_Y*Y                1.000  0.588  0.257 
32  X1_Y*X1*Xtest                     1.000  0.588  0.257 
33  X1_Y*X1*Xtest_Y                   1.000  0.588  0.257 
34  X1_Y*X1*Y                         1.000  0.588  0.257 
35  X1_Y*Xtest*Xtest_Y                1.000  0.588  0.257 
36  X1_Y*Xtest*Y                      1.000  0.588  0.257 
37  X1_Y*Xtest_Y*Y                    1.000  0.588  0.257 
38  X1*Xtest*Xtest_Y                  1.000  0.034  0.129 
39  X1*Xtest*Y                        1.000  0.034  0.129 
40  X1*Xtest_Y*Y                      1.000  0.034  0.129 
41  Xtest*Xtest_Y*Y                   1.000  0.000  0.125 
42  X1_Xtest*X1_Y*X1*Xtest            1.000  0.865  0.514 
43  X1_Xtest*X1_Y*X1*Xtest_Y          1.000  0.865  0.514 
44  X1_Xtest*X1_Y*X1*Y                1.000  0.865  0.514 
45  X1_Xtest*X1_Y*Xtest*Xtest_Y       1.000  0.865  0.514 
46  X1_Xtest*X1_Y*Xtest*Y             1.000  0.865  0.514 
47  X1_Xtest*X1_Y*Xtest_Y*Y           1.000  0.865  0.514 
48  X1_Xtest*X1*Xtest*Xtest_Y         1.000  0.588  0.257 
49  X1_Xtest*X1*Xtest*Y               1.000  0.588  0.257 
50  X1_Xtest*X1*Xtest_Y*Y             1.000  0.588  0.257 
51  X1_Xtest*Xtest*Xtest_Y*Y          1.000  0.588  0.257 
52  X1_Y*X1*Xtest*Xtest_Y             1.000  0.588  0.257 
53  X1_Y*X1*Xtest*Y                   1.000  0.588  0.257 
54  X1_Y*X1*Xtest_Y*Y                 1.000  0.588  0.257 
55  X1_Y*Xtest*Xtest_Y*Y              1.000  0.588  0.257 
56  X1*Xtest*Xtest_Y*Y                1.000  0.034  0.129 
57  X1_Xtest*X1_Y*X1*Xtest*Xtest_Y    1.000  0.865  0.514 
58  X1_Xtest*X1_Y*X1*Xtest*Y          1.000  0.865  0.514 
59  X1_Xtest*X1_Y*X1*Xtest_Y*Y        1.000  0.865  0.514 
60  X1_Xtest*X1_Y*Xtest*Xtest_Y*Y     1.000  0.865  0.514 
61  X1_Xtest*X1*Xtest*Xtest_Y*Y       1.000  0.588  0.257 
62  X1_Y*X1*Xtest*Xtest_Y*Y           1.000  0.588  0.257 
63  X1_Xtest*X1_Y*X1*Xtest*Xtest_Y*Y  1.000  0.865  0.514 
64  ~X1_X2 + X2                       1.000  0.000  0.125 
65  ~X1_X3 + X3                       1.000  0.000  0.125 
66  ~X1_X4 + X4                       1.000  0.000  0.125 
67  ~X2_X3 + X2                       1.000  0.000  0.125 
68  ~X2_X3 + X3                       1.000  0.000  0.125 
69  ~X2_Xtest + ~X2_Y                 1.000  0.277  0.165 
70  ~X2_Xtest + X2                    1.000  0.000  0.125 
71  ~X2_Y + X2                        1.000  0.000  0.125 
72  ~X2_X4 + X2                       1.000  0.000  0.125 
73  ~X2_X4 + X4                       1.000  0.000  0.125 
74  ~X3_Xtest + ~X3_Y                 1.000  0.278  0.165 
75  ~X3_Xtest + X3                    1.000  0.000  0.125 
76  ~X3_Y + X3                        1.000  0.000  0.125 
77  ~X3_X4 + X3                       1.000  0.000  0.125 
78  ~X3_X4 + X4                       1.000  0.000  0.125 
79  ~Xtest_X4 + X4                    1.000  0.000  0.125 
80  ~Y_X4 + X4                        1.000  0.000  0.125 
81  X2 + X3                           1.000  0.000  0.125 
82  X2 + X4                           1.000  0.000  0.125 
83  X3 + X4                           1.000  0.000  0.125 
84  ~X2_X3 + ~X2_Xtest + ~X3_Y        1.000  0.135  0.141 
85  ~X2_X3 + ~X2_Y + ~X3_Xtest        1.000  0.135  0.141 
--------------------------------------------------------- 


## Comparing DAGs

### Generate Models

#### Different Configurations

We will develop an easier method, but for now we do the 'long way' of assembling all (most) possible model combinations of the edges and nodes

```{r searching_dags}
nodes <- c("a","b","c","d","e","f")
timing <- c(0,-1,-2,-3,-3, 1)
types <- c("otc","test","ctr","ctr", "ctr","ctr")
user_mods <- c("a ~ b + d; b ~ c + d", # Model 1
               "a ~ b + c; b ~ c + d", # Model 2
               "a ~ b + c + d; b ~ c + d", # Model 3
               "a ~ b + d; b ~ c + d; f ~ a + b", # Model 4, add later
               "a ~ b + d; b ~ d; c ~ c", # Model 5
               "a ~ b + d; b ~ c + d + e; e ~ d" # Model 6
               )

tic()
ls_theory2 <- theoRy(nodes = nodes, timing = timing, types=types, include_subsets = TRUE, user_mods=user_mods)
toc()
```

