---
title: "02 Working Paper"
author: "Nate Breznau & Hung H.V. Nguyen"
date: "`r Sys.Date()`"
output: html_document
---

## R Markdown

```{r setup}

source("R/theoRy.R")
library('tictoc')
library('QCA')

```

## Generate Model Multiverse

### Generate causal and formula matrix

```{r models}
nodes <- c("a","b","c","d","e")
timing <- c(0,-1,-3,-3,-2)
types <- c("otc","test","ctr","ctr", "ctr")
user_mods <- c("a ~ b + d; b ~ c + d", # Model 1
               "a ~ b + c; b ~ c + d", # Model 2
               "a ~ b + c + d; b ~ c + d", # Model 3
               #"a ~ b + d; b ~ c + d; f ~ a + b", # Model 4, add later
               "a ~ b + d; b ~ d; c ~ c", # Model 5
               "a ~ b + d; b ~ c + d + e; e ~ d" # Model 6
               )

tic()
ls_theory <- theoRy(nodes = nodes, timing = timing, types=types, include_subsets = TRUE, user_mods=user_mods)
toc()
```

### Add Model 4

With X4 in the model, the multiverse is huge. for now we simply add the confounding Model 4 as a single model that might threaten this multiverse for illustrative purposes.

Adding a single model with a new variable requires adjusting the node_timing matrix too (we will update this later)

when theoRy is run the model numbers change
1 = 3
2 = 5
3 = 2
4 = 6 (after addition)
5 = 4
6 = 1

```{r m4}
# add X4 to node_timing
ls_theory$node_timing <- ls_theory$node_timing %>% add_row(var_name = "f", timing = 1, type = "ctr", node_name = "X4")

ls_theory$causal_matrix <- find_add_models(causal_matrix = ls_theory$causal_matrix, node_timing = ls_theory$node_timing, user_mods = c("a ~ b + d; b ~ c + d; f ~ a + b"))

# rearrange so that models 1 thru 6 match Table 1 numbering
ls_theory$causal_matrix <- ls_theory$causal_matrix %>%
    mutate(model = dplyr::recode(model,
                  `3` = 1,
                  `5` = 2,
                  `2` = 3,
                  `1166` = 4,
                  `4` = 5,
                  `1` = 6,
                  .default = model
                  )) %>%
    arrange(model)

ls_theory$formula_matrix <- build_formula_matrix(ls_theory$causal_matrix)

```
### Table 2

```{r t2}
Table_2 <- subset(ls_theory$causal_matrix, model %in% c(1,3,4,5), select = c(from, to, timing_from, timing_to, model))

write.csv(Table_2, here::here("Results", "Table_2.csv"), row.names = F)
```

### Compare Models

```{r models}
cmp_matrix <- add_compatible(ls_theory$formula_matrix, ref_mod = 1)

## Change ref_mod to whichever is your reference model (using base_mod and model variable in the formula matrix)
```



### Generate DAG formulas

```{r gen_dags}

dag_matrix <- build_dag_matrix(ls_theory$formula_matrix, add_nodes = 2)

```

### Generate Plots

Only need to save models 1-6 for the paper

```{r gen_plots, warning = F}
dag_plots <- plot_dag_matrix(dag_matrix, save_plots = TRUE, choose_plots = c(2,6,8,18,33,34), title_labels = c(3,1,5,2,4,6))


```




##### Playing around with plotting as ggdag

```{r ggdag}

fvector <- strsplit(as.character(formula_matrix[1]), ",")[[1]]
dag_args <- lapply(fvector, as.formula)
additional_args <- list(
     exposure="Xtest",
     outcome="Y"
     )

d1 <- do.call(dagify, c(dag_args, additional_args))


ggdag(d1)

d1plot <- ggdag(d1) +
    geom_dag_edges(edge_color = "green")

```


## QCA

### Build Set Matrix

Here we focus on test_compatible as the outcome (= 1)

We use cmp_matrix to get this information

```{r build_set_matrix}
set_matrix <- build_set_matrix(ls_theory$causal_matrix, cmp_matrix = cmp_matrix)

# think about whether we want model numbers in or not, just remove by hand here

set_matrix_c <- dplyr::select(set_matrix, -model)
```




### Single Components

This can help us understand the role of single components. However, for most causal models a single component is rarely alone so important. For example a node often requires specific edges before it becomes important (e.g., becomes a confounder or collider)

```{r qca}
set_truth <- truthTable(set_matrix, "outcome")

set_pof <- pof(setms = select(set_matrix, -c(model,outcome)), outcome = "outcome", data = set_matrix)

# try option relation = "sufficiency"

#inclN = inclusion = what percent of all models have outcome (Y = 1) and this component (X = 1)
#covN = necessity coverage = what percent of all models with this component (X = 1) have the outcome (Y = 1)
#RoN = relevence of necessity = is a necessary condition trivial
```


### Multiple Component Analyses

#### Minimize

Looking only positive outcomes (outcome = 1/MAS = {X1}), this procedure tries to find minimal sets of variables that are present in all positive cases, regardless of if these sets are present in outcome = 0 cases.

```{r minimize}

min_results <- minimize(set_matrix_c, details = TRUE, outcome = "outcome")

```


#### Subsets

*inclN* = inclusion = what percent of all models have outcome (Y = 1) and this component (X = 1)
*covN* = necessity coverage = what percent of all models with this component (X = 1) have the outcome (Y = 1)
*RoN* = relevence of necessity = is a necessary condition trivial
```{r qca}
s_subset <- superSubset(set_matrix_c, outcome = "outcome")
```

 


## Comparing DAGs

### Generate Models

#### Different Configurations

We will develop an easier method, but for now we do the 'long way' of assembling all (most) possible model combinations of the edges and nodes

```{r searching_dags}
nodes <- c("a","b","c","d","e","f")
timing <- c(0,-1,-2,-3,-3, 1)
types <- c("otc","test","ctr","ctr", "ctr","ctr")
user_mods <- c("a ~ b + d; b ~ c + d", # Model 1
               "a ~ b + c; b ~ c + d", # Model 2
               "a ~ b + c + d; b ~ c + d", # Model 3
               "a ~ b + d; b ~ c + d; f ~ a + b", # Model 4, add later
               "a ~ b + d; b ~ d; c ~ c", # Model 5
               "a ~ b + d; b ~ c + d + e; e ~ d" # Model 6
               )

tic()
ls_theory2 <- theoRy(nodes = nodes, timing = timing, types=types, include_subsets = TRUE, user_mods=user_mods)
toc()
```

