---
title: "02 Working Paper"
author: "Nate Breznau & Hung H.V. Nguyen"
date: "`r Sys.Date()`"
output: html_document
---

## R Markdown

```{r setup}

source("R/theoRy.R")
library('tictoc')
library('QCA')

```

## Showcase how functions work

### Generate causal and formula matrix

```{r models}
nodes <- c("a","b","c","d","e")
timing <- c(0,-1,-3,-3,-2)
types <- c("otc","test","ctr","ctr", "ctr")
user_mods <- c("a ~ b + d; b ~ c + d", # Model 1
               "a ~ b + c; b ~ c + d", # Model 2
               "a ~ b + c + d; b ~ c + d", # Model 3
               #"a ~ b + d; b ~ c + d; f ~ a + b", # Model 4, add later
               "a ~ b + d; b ~ d; c ~ c", # Model 5
               "a ~ b + d; b ~ c + d + e; e ~ d" # Model 6
               )


tic()
ls_theory <- theoRy(nodes = nodes, timing = timing, types=types, include_subsets = TRUE, user_mods=user_mods)
toc()



## Add model 4 with an extra node (f). Assert model number = 4


ls_theory <- find_add_models(ls_theory = ls_theory, on_ls=TRUE, add_nodes = list(c(var_name = "f", timing = 1, type = "ctr", node_name = "X4")), user_mods = c("a ~ b + d; b ~ c + d; f ~ a + b"), assert_mod_num = 4)

test <- copy(ls_theory)

## If you run a second time, ls_theory should let users know whether models or nodes exists

test <- find_add_models(ls_theory = test, on_ls=TRUE, add_nodes = list(c(var_name = "f", timing = 1, type = "ctr", node_name = "X4")), user_mods = c("a ~ b + d; b ~ c + d; f ~ a + b"), assert_mod_num = 4)

## Can also change swap model numbers. 

test <- find_add_models(ls_theory = test, on_ls=TRUE, add_nodes = list(c(var_name = "f", timing = 1, type = "ctr", node_name = "X4")), user_mods = c("a ~ b + d; b ~ c + d; f ~ a + b", "a ~ b + d; b ~ c + d + e; e ~ d"), assert_mod_num = c(6,4))


## Can add and swap at the same time. Here, model 1-2 and an implausible model `max(causal_matrix$model)+1` becomes model 3-1-2
test <- find_add_models(ls_theory = test, on_ls=TRUE, add_nodes = list(c(var_name = "f", timing = 1, type = "ctr", node_name = "X4")), user_mods = c("a ~ b + d; b ~ c + d", "a ~ b + c; b ~ c + d", "a ~ b + c + d; b ~ c + d; d~e"), assert_mod_num = c(3,1,2))







```


### Compare Models

```{r models}
cmp_matrix <- add_compatible(ls_theory$formula_matrix, ref_mod = 1)

## Change ref_mod to whichever is your reference model (using base_mod and model variable in the formula matrix)
```


### Generate Plots

Only need to save models 1-6 for the paper

```{r gen_plots, warning = F}
dag_plots <- plot_dag(ls_theory, choose_plots=c(1,2,3,4,5,6), save_path="Results/")

for(plot in dag_plots){
    print(plot)
}
```


### Build set matrix

```{r}
set_matrix <- build_set_matrix(ls_theory$causal_matrix, cmp_matrix = cmp_matrix)

```











## Generate Model Multiverse

### Generate causal and formula matrix


```{r six_var_comp}
nodes <- c("a","b","c","d","e","f")
timing <- c(0,-1,-2,-3,-3, 1)
types <- c("otc","test","ctr","ctr", "ctr","ctr")
user_mods <- c("a ~ b + d; b ~ e + d", # Model 1
               "a ~ b + e; b ~ e + d", # Model 2
               "a ~ b + e + d; b ~ e + d", # Model 3
               "a ~ b + d; b ~ e + d; f ~ a + b", # Model 4
               "a ~ b + d; b ~ d; e ~ e", # Model 5
               "a ~ b + d; b ~ d + c + e; c ~ e" # Model 6
               )

tic()
ls_theory2 <- theoRy(nodes = nodes, timing = timing, types=types, include_subsets = TRUE, user_mods=user_mods)
toc()

# On the server this took 12767.746 sec elapsed
```
### Table 2

```{r t2}
Table_2 <- subset(ls_theory$causal_matrix, model %in% c(1,3,4,5), select = c(from, to, timing_from, timing_to, model))

write.csv(Table_2, here::here("Results", "Table_2.csv"), row.names = F)
```

```{r cmp}
cmp_matrix <- add_compatible(ls_theory2$formula_matrix, ref_mod = 1)

saveRDS(ls_theory2, here::here("Results", "ls_theory2.RDS"))
saveRDS(cmp_matrix, here::here("Results", "cmp_matrix_theory2.RDS"))

```
### Generate DAG formulas

```{r gen_dags}

dag_matrix <- build_dag_matrix(ls_theory$formula_matrix, add_nodes = 2)

```

### Generate Plots

Only need to save models 1-6 for the paper

```{r gen_plots, warning = F}
dag_plots <- plot_dag_matrix(dag_matrix, save_plots = TRUE, choose_plots = c(2,6,8,18,33,34), title_labels = c(3,1,5,2,4,6))


```




##### Playing around with plotting as ggdag

```{r ggdag}

fvector <- strsplit(as.character(formula_matrix[1]), ",")[[1]]
dag_args <- lapply(fvector, as.formula)
additional_args <- list(
     exposure="Xtest",
     outcome="Y"
     )

d1 <- do.call(dagify, c(dag_args, additional_args))


ggdag(d1)

d1plot <- ggdag(d1) +
    geom_dag_edges(edge_color = "green")

```


## QCA

### Build Set Matrix

Here we focus on test_compatible as the outcome (= 1)

We use cmp_matrix to get this information

```{r build_set_matrix}
set_matrix <- build_set_matrix(ls_theory$causal_matrix, cmp_matrix = cmp_matrix)

# think about whether we want model numbers in or not, just remove by hand here

set_matrix_c <- dplyr::select(set_matrix, -model)
```




### Single Components

This can help us understand the role of single components. However, for most causal models a single component is rarely alone so important. For example a node often requires specific edges before it becomes important (e.g., becomes a confounder or collider)

```{r qca}
set_truth <- truthTable(set_matrix, "outcome")

set_pof <- pof(setms = select(set_matrix, -c(model,outcome)), outcome = "outcome", data = set_matrix)

# try option relation = "sufficiency"

#inclN = inclusion = what percent of all models have outcome (Y = 1) and this component (X = 1)
#covN = necessity coverage = what percent of all models with this component (X = 1) have the outcome (Y = 1)
#RoN = relevence of necessity = is a necessary condition trivial
```


### Multiple Component Analyses

#### Minimize

Looking only positive outcomes (outcome = 1/MAS = {X1}), this procedure tries to find minimal sets of variables that are present in all positive cases, regardless of if these sets are present in outcome = 0 cases.

```{r minimize}

min_results <- minimize(set_matrix_c, details = TRUE, outcome = "outcome")

```


#### Subsets

*inclN* = inclusion = what percent of all models have outcome (Y = 1) and this component (X = 1)
*covN* = necessity coverage = what percent of all models with this component (X = 1) have the outcome (Y = 1)
*RoN* = relevence of necessity = is a necessary condition trivial
```{r qca}
s_subset <- superSubset(set_matrix_c, outcome = "outcome")
```
